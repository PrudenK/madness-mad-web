---

---
<article class="doc-article">
    <section id="algorithms" class="doc-section">
        <section class="doc-subsection">
            <h2 class="doc-h2">Algoritmos</h2>
            <p class="doc-p">
                Se seleccionan desde el menú <span class="doc-pill">Algoritmos</span>. La ejecución se realiza con <span class="doc-pill">Ejecutar</span>.
            </p>
        </section>


        <section id="algorithms-animations" class="doc-subsection">
            <h3 class="doc-h3">Animaciones</h3>

            <p class="doc-p">
                Desde la pestaña de <span class="doc-pill">Ajustes</span> puedes configurar el comportamiento de las animaciones.
                Existen dos grupos de algoritmos: los que usan <strong>animación rápida</strong>
                (DFS, Dijkstra, Bellman–Ford, Hierholzer, Cartero Chino y los ciclos hamiltonianos) y el resto, que emplean
                <strong>animación normal</strong> o no tienen animación.
            </p>

            <p class="doc-p">
                Las animaciones disponen de dos parámetros configurables:
                <strong>duración de la animación</strong>, que define el tiempo que tarda en dibujarse cada arista,
                y <strong>retraso entre niveles</strong>, que indica la espera antes de pintar la siguiente arista
                o conjunto de aristas.
            </p>


        </section>


        <section id="algorithms-list" class="doc-subsection">
            <h3 class="doc-h3">Algoritmos implementados</h3>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">BFS (Breadth-First Search)</h4>

                <p class="doc-p">
                    El algoritmo BFS (Breadth-First Search) recorre el grafo por niveles a partir de un vértice
                    origen, visitando primero todos los vértices adyacentes antes de avanzar a niveles más profundos.
                </p>
                <p class="doc-p">
                    Este tipo de recorrido garantiza que la primera vez que se alcanza un vértice se ha seguido
                    el camino con menor número de aristas desde el origen. Por este motivo, BFS permite calcular
                    distancias mínimas en grafos no ponderados y es especialmente útil para estudiar la conectividad
                    y la estructura general del grafo.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>No tiene restricciones</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se pide el nodo de origen.</li>
                    <li>Se anima por niveles.</li>
                    <li>Muestra el orden de visita en el panel de información.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/OiNrD0UUxRI" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">DFS (Depth-First Search)</h4>
                <p class="doc-p">
                    DFS explora el grafo siguiendo un camino hasta donde sea posible, avanzando de vértice en vértice
                    sin retroceder hasta que no quedan opciones disponibles.
                </p>
                <p class="doc-p">
                    Cuando alcanza un vértice sin vecinos no visitados, el algoritmo retrocede para continuar la
                    exploración desde el último punto pendiente. Este comportamiento permite analizar la estructura
                    del grafo, detectar ciclos y descomponerlo en componentes conexas, además de servir como base
                    para algoritmos más avanzados.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>No tiene restricciones</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se pide el nodo de origen.</li>
                    <li>Se anima arista por arista.</li>
                    <li>Muestra el orden de visita en el panel de información.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/RJblr2YddXg" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Dijkstra</h4>
                <p class="doc-p">
                    El algoritmo de Dijkstra calcula los caminos mínimos desde un vértice origen al resto de vértices
                    mediante un proceso iterativo de relajación de aristas.
                </p>
                <p class="doc-p">
                    Garantiza resultados óptimos siempre que los pesos sean no negativos, siendo uno de los algoritmos
                    fundamentales para el cálculo de rutas y costes mínimos.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo ponderado (si no lo es todas las aristas valen 1)</li>
                    <li>Pesos no negativos</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se pide el nodo de origen.</li>
                    <li>Se pide el nodo destino, se puede seleccionar también todos.</li>
                    <li>Muestra el camino (o caminos) de la forma V<sub>1</sub> → V<sub>2</sub> → … → V<sub>n</sub>.</li>
                    <li>También muestra el peso de cada camino.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/OvRUQ7aSJWI" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Bellman–Ford</h4>
                <p class="doc-p">
                    Bellman–Ford calcula caminos mínimos repitiendo la relajación de todas las aristas del grafo,
                    permitiendo trabajar con pesos negativos.
                </p>
                <p class="doc-p">
                    Además, es capaz de detectar ciclos de coste negativo, lo que lo hace especialmente útil para
                    validar la coherencia de grafos ponderados.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo ponderado (si no lo es todas las aristas valen 1)</li>
                    <li>No se permiten ciclos negativos</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se pide el nodo de origen.</li>
                    <li>Se pide el nodo destino, se puede seleccionar también todos.</li>
                    <li>Muestra el camino (o caminos) de la forma V<sub>1</sub> → V<sub>2</sub> → … → V<sub>n</sub>.</li>
                    <li>También muestra el peso de cada camino.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/6xtkWErPsPk" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Kruskal</h4>
                <p class="doc-p">
                    El algoritmo de Kruskal construye un árbol de expansión mínima o máxima seleccionando aristas
                    de menor o mayor peso y añadiéndolas siempre que no formen ciclos.
                </p>
                <p class="doc-p">
                    Puede aplicarse a grafos incluso si no son conexos. En ese caso,
                    el resultado es un bosque de expansión, con un árbol por cada componente conexa, optimizando
                    el coste total en cada una de ellas.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo ponderado (si no lo es todas las aristas valen 1)</li>
                    <li>Grafo no dirigido</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se da a elegir entre árbol maximal o minimal.</li>
                    <li>Se pintan todas las aristas del árbol resultante.</li>
                    <li>Muestra el peso total del árbol (o bosque) en el panel de información.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/HUyQmgY5HN4" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Edmonds2 (Emparejamiento máximo)</h4>
                <p class="doc-p">
                    El algoritmo Edmonds 2 calcula un emparejamiento en un grafo no dirigido y ponderado,
                    maximizando siempre el número de aristas emparejadas.
                </p>

                <p class="doc-p">
                    Una vez alcanzada la máxima cardinalidad posible, el algoritmo optimiza el peso total
                    del emparejamiento. En modo MAX se selecciona el emparejamiento de mayor peso, y en modo
                    MIN el de menor peso, sin reducir en ningún caso el número de parejas.
                </p>

                <p class="doc-p">
                    Esta prioridad se garantiza mediante una reducción del problema a un emparejamiento perfecto,
                    evitando que la optimización del peso afecte al tamaño del emparejamiento.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo ponderado</li>
                    <li>Grafo no dirigido</li>
                    <li>Al menos dos vértices y una arista</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se da a elegir entre peso máximo o mínimo.</li>
                    <li>Se pintan las aristas resultantes.</li>
                    <li>Muestra la cardinalidad y peso total del acoplamiento.</li>
                    <li>También da información de las aristas escogidas.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/PYcRCe6ck8E" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Hierholzer</h4>
                <p class="doc-p">
                    El algoritmo de Hierholzer encuentra un camino o ciclo euleriano recorriendo todas las aristas
                    del grafo exactamente una vez.
                </p>
                <p class="doc-p">
                    Comienza construyendo un ciclo inicial y, mientras existan vértices del recorrido con aristas
                    sin visitar, genera nuevos ciclos que se insertan en el recorrido ya construido hasta
                    obtener una única trayectoria que incluye todas las aristas.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo euleriano</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Si es un ciclo euleriano la animación muestra el camino euleriano cerrado.</li>
                    <li>En el panel de información se muestra la ruta completa.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/BMj6CdSC0yg" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Cartero Chino</h4>
                <p class="doc-p">
                    El algoritmo del cartero chino busca un recorrido cerrado de coste mínimo que pase por todas
                    las aristas del grafo al menos una vez.
                </p>
                <p class="doc-p">
                    Si el grafo no es euleriano, el algoritmo identifica los vértices que impiden la existencia
                    de un ciclo euleriano y añade recorridos auxiliares mínimos para equilibrarlo. Una vez
                    equilibrado, se aplica un recorrido euleriano, integrando las aristas originales y las
                    añadidas en una única trayectoria cerrada.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo conexo</li>
                    <li>Grafo fuertemente conexo en grafos dirigidos</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Muestra la animación del ciclo euleriano resultante.</li>
                    <li>Las aristas auxiliares se pintan de verde.</li>
                    <li>En el panel de información se muestra la ruta completa.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/ldUMthFrlpo" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Ford–Fulkerson</h4>
                <p class="doc-p">
                    El algoritmo de Ford–Fulkerson calcula el flujo máximo entre un nodo origen y un nodo destino en
                    una red mediante la búsqueda de caminos aumentantes.
                </p>
                <p class="doc-p">
                    Ajusta progresivamente las capacidades residuales y sirve como base para el estudio de redes de
                    flujo y optimización de recursos.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo dirigido y débilmente conexo</li>
                    <li>Aristas con peso no negativo</li>
                    <li>Grafo ponderado</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se pide el nodo fuente.</li>
                    <li>Se pide el nodo sumidero.</li>
                    <li>Se muestra una animación camino por camino de flujo.</li>
                    <li>En el panel se muestra el flujo máximo de la red.</li>
                    <li>También se muestra capacidad y flujo arista por arista.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/RcsddDsp9QM" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Hamilton (bajo peso)</h4>
                <p class="doc-p">
                    Este algoritmo busca un ciclo hamiltoniano de bajo peso mediante heurísticas (por ende puede fallar), priorizando
                    aristas de menor coste sin garantizar una solución óptima global.
                </p>
                <p class="doc-p">
                    En MadnessMad se ofrecen dos estrategias: un enfoque <strong>voraz (Greedy)</strong>, que avanza
                    eligiendo localmente la mejor arista disponible, y un enfoque basado en
                    <strong>árbol de expansión mínima (MST)</strong>, que utiliza la estructura del árbol para guiar
                    la construcción del ciclo.
                </p>
                <p class="doc-p">
                    Ambos métodos reducen significativamente el coste computacional frente a la búsqueda exhaustiva,
                    siendo adecuados para grafos de mayor tamaño cuando se desea una solución razonable en tiempo
                    práctico.
                </p>


                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo no dirigido</li>
                    <li>Grafo conexo</li>
                    <li>Aristas con peso no negativo</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se da a elegir entre ejecución "Greedy" y "MST-based".</li>
                    <li>Se pide el nodo de origen.</li>
                    <li>Se muestra una animación para el camino hamiltoniano (si se encuentra).</li>
                    <li>En el panel se muestra el peso total y la ruta del camino.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://youtu.be/QIwAIHifaVs" target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Hamilton (mínimo peso)</h4>
                <p class="doc-p">
                    Calcula el camino hamiltoniano de menor coste evaluando todas las combinaciones posibles mediante
                    fuerza bruta.
                </p>
                <p class="doc-p">
                    Garantiza la solución óptima, aunque su complejidad exponencial lo limita a grafos pequeños.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo pequeño (hasta 10 vértices)</li>
                    <li>Grafo no dirigido</li>
                    <li>Grafo conexo</li>
                    <li>Aristas con peso no negativo</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se pide el nodo de origen.</li>
                    <li>Se muestra una animación para el camino hamiltoniano.</li>
                    <li>En el panel se muestra el peso total y la ruta del camino.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://www.youtube.com/..." target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>

            <section class="doc-algorithm-card">
                <h4 class="doc-h4">Hopcroft–Tarjan</h4>
                <p class="doc-p">
                    El algoritmo de Hopcroft–Tarjan identifica vértices de corte y aristas puente en grafos no dirigidos.
                </p>
                <p class="doc-p">
                    Permite analizar la robustez y los puntos críticos de la estructura del grafo.
                </p>

                <p class="doc-p"><strong>Requisitos de ejecución</strong></p>
                <ul class="doc-ul">
                    <li>Grafo no dirigido</li>
                </ul>
                <p class="doc-p">
                    <strong>Ejecución en MadnessMad</strong><br>
                </p>
                <ul class="doc-ul">
                    <li>Se muestran pintadas las aristas y vértices de corte.</li>
                </ul>

                <p class="doc-p">
                    <strong>Recursos adicionales</strong><br>
                    <a class="doc-link" href="https://www.youtube.com/..." target="_blank">
                        Ver ejecución del algoritmo (YouTube)
                    </a>
                </p>
            </section>
        </section>


    </section>
</article>